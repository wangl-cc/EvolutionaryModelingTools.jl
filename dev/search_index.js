var documenterSearchIndex = {"docs":
[{"location":"reference/#References","page":"References","title":"References","text":"","category":"section"},{"location":"reference/","page":"References","title":"References","text":"Modules = [EvolutionaryModelingTools, EvolutionaryModelingTools.Scalar]","category":"page"},{"location":"reference/#EvolutionaryModelingTools.Reaction","page":"References","title":"EvolutionaryModelingTools.Reaction","text":"Reaction{C,U}\n\nContain a \"calculate\" function and an \"update\" function. The \"calculate\" function calculates the a \"rate\" of reaction with the system state, which determines the probability weight of the reaction be selected, and the \"update\" function updates the system state, when this reaction were selected randomly.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EvolutionaryModelingTools.gillespie!-Tuple{Any, Random.AbstractRNG, RecordedArrays.ContinuousClock, NamedTuple, Tuple}","page":"References","title":"EvolutionaryModelingTools.gillespie!","text":"gillespie!(hook!, rng::AbstractRNG, c::ContinuousClock, ps::NamedTuple, rs::Tuple)\n\nSimulate the system using the Gillespie algorithm with the given parameters, and return a tuple of end time and the terminate state :finnish, :zero or any other state returns by the hook!. The terminate state :finnish means that simulation reach to the end time, and :zero means the simulation break because the total \"reaction rate\" is zero, besides, hook! should return a symbol terminate state like :break. if the return value of hook! is not :finnish, the simulation will be terminated. The clock c and parameters ps will be updated during the simulation.\n\nArguments\n\nhook!: a function with similar arguments to \"update\" functions,  and it's recommended to create hook! with @ufunc macro;  unlike \"update\" functions, hook will be called after each reaction  and should return a terminate state used to terminate the simulation if it is not :finnish.\nrng: a random number generator for generate random numbers;\nc: a clock recording time, which must be the reference clock of recorded variables in ps;\nps: a NamedTuple contains state, parameters even args used by hook! of the system;\nrs: a tuple contains reactions, all parameters required by reactions must be in ps with same name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EvolutionaryModelingTools.gillespie-Tuple{Any, Random.AbstractRNG, Any, NamedTuple, Tuple}","page":"References","title":"EvolutionaryModelingTools.gillespie","text":"gillespie([hook!, rng::AbstractRNG,] c, ps::NamedTuple, rs::Tuple)\n\nSimulate the system using the Gillespie algorithm with the given parameters, and return a tuple of updated ps, end time and terminate state. More about terminate state, see gillespie!.\n\nArguments\n\nhook!: a function with similar arguments to \"update\" functions  and recommended to created with @ufunc macro;  unlike \"update\" functions, hook will be called after each reaction  and should return a terminate state used to terminate the simulation if it is not :finnish.\nrng: a random number generator for generate random numbers;\nc: a ContinuousClock, a end time or a tuple of a begin and a end time;\nps: a NamedTuple contains state, parameters even args used by hook! of the system;\nrs: a tuple contains reactions, all parameters required by reactions must be in ps with same name.\n\ninfo: Info\nIn order to update single value state, it must be converted to a ScalarType with scalar.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EvolutionaryModelingTools.sample","page":"References","title":"EvolutionaryModelingTools.sample","text":"sample(A::AbstractArray{<:Real,N}, rn::Real) -> CartesianIndex{N}\n\nSelect a cartesian index of given weight array A and random number rn, where A should be an AbstractArray with element type of Real.\n\nExample\n\njulia> A = reshape(1:4, 2, 2)\n2×2 reshape(::UnitRange{Int64}, 2, 2) with eltype Int64:\n 1  3\n 2  4\n\njulia> EvolutionaryModelingTools.sample(A, 1)\nCartesianIndex(1, 1)\n\njulia> EvolutionaryModelingTools.sample(A, 2)\nCartesianIndex(2, 1)\n\njulia> EvolutionaryModelingTools.sample(A, 4)\nCartesianIndex(1, 2)\n\njulia> EvolutionaryModelingTools.sample(A, 7)\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"reference/#EvolutionaryModelingTools.@cfunc-Tuple{Any}","page":"References","title":"EvolutionaryModelingTools.@cfunc","text":"@cfunc ex\n\nDefine a \"calculation\" function with an \"adapter\" methods used to parse args from model. \"calculate\" functions take arguments from system state and calculate \"rate\"s determining the probability weight of the reaction be selected.\n\nExample\n\nFor function definition:\n\n@cfunc @inline growth_c(r, x::Vector) = r * x # function to calculate \"growth rate\"\n\nThis macro creates two methods, an \"adapter\" method\n\ngrowth_c(args::NamedTuple) = growth_c(args.r, args.x)\n\nand the origin method\n\n@inline growth_c(r, x::Vector) = r * x\n\ninfo: Info\nFor function definition with other macros, put those macros after this macro.\n\nwarning: Warning\nThe argument name t is reserved for time. Don't use those variable names for other usage\n\n\n\n\n\n","category":"macro"},{"location":"reference/#EvolutionaryModelingTools.@quickloop-Tuple","page":"References","title":"EvolutionaryModelingTools.@quickloop","text":"@quickloop ex opts...\n\nGenerate a function to calculate given expression with nested loops.\n\nExample\n\n@quickloop x[i] * m[i, j] * y[j]\n\nwill generate a function\n\n(m, y, x)->begin\n    ret = Array{...}(undef, size(m, 1), size(m, 2)) # expression for type inference is omitted\n    @fastmath @inbounds for j = axes(m, 2), i = axes(m, 1)\n        ret[i, j] = x[i] * m[i, j] * y[j]\n    end\n    return ret\nend\n\nwhere the size of return array is determined automatically. The size can be specified by\n\n@quickloop z[j, i] := x[i] * m[i, j] * y[j]\n\nwhich will generate a function\n\n(m, y, x)->begin\n    z = Array{...}(undef, size(m, 2), size(m, 1)) # expression for type inference is omitted\n    @fastmath @inbounds for i = axes(m, 1), j = axes(m, 2)\n        z[j, i] = x[i] * m[i, j] * y[j]\n    end\n    return z\nend\n\nwhere the return value is named by z and the size of return array is (size(m, 2), size(m, 1)) instead of (size(m, 1), size(m, 2)).\n\nOptions\n\nOptions should be specified like @quickloop ex opt=true/false or @quickloop ex opt, if the value of option is omitted, it will be treated as true.\n\navx or turbo: use LoopVectorization to accelerate the loop, default is false,   unless LoopVectorization have be loaded.\ninbounds: use @inbounds to accelerate the loop, default is true, this option is ignored   if avx or turbo is enabled.\nfastmath: use @fastmath to accelerate the loop, default is true, this option is ignored   if avx or turbo is enabled.\noffset: if true, input arrays will be treat as offset arrays, default is false.\n\nnote: Note\nThe order of function arguments generated by this macro is undetermined. Thus, it's recommender use this macro inside of @reaction, which detect the order of function arguments automatically.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#EvolutionaryModelingTools.@reaction-Tuple{Symbol, Expr}","page":"References","title":"EvolutionaryModelingTools.@reaction","text":"@reaction name ex\n\nDefine a Reaction with the given name and ex.\n\n@reaction growth begin\n    r * x # \"calculate\" expression\n    begin\n        i = ind[1]\n        x[i] += 1 # \"update\" expression\n    end\nend\n\nwill create a Reaction with a \"calculation\" function:\n\n@cfunc Base.@propagate_inbounds growth_c(r, x) = r * x\n\nand an \"update\" function:\n\n@ufunc Base.@propagate_inbounds growth_u!(ind, x) = begin\n    i = ind[1]\n    x[i] += 1\nend\n\nwhere arguments of functions were collected from given expression automatically.\n\nnote: Note\nIf there are global variables, this macro may can not collect arguments correctly. Especially, for functions which accept function and types as arguments, those functions and types may also be collect as an arguments. Thus, these variables must be marked as global variables by global before use them, even functions and types. Besides, type annotation expressions like x::Vector{Int}, types Vector and Int will not be collected. Avoid to defined your reaction with a type arguments for type annotation.\n\nwarning: Warning\nThe expression follow the same name preserve rule as @cfunc and @ufunc, don't use those variable names for other usage.\n\nThis macro cannot parse macro expression. Thus in some cases, arguments of expression with macro may not be collected correctly. To avoid this, define reaction with anonymous functions may helpfully:\n\n@reaction reaction begin\n    (A, B) -> @einsum C[i, k] := A[i, j] * B[j, k] # where C, i, j, k should not be collected\n    begin\n        # do something\n    end\nend\n\nin this case, only arguments of anonymous function (A and B) will be collected.\n\nBesides, there are another macro @quickloop, which is similar to @einsum, but it don't follow the einstein convenience which just generate nest loops out of the expression. Because the @quickloop generate a function and arguments are provided, indexing variables and return variable will not be collected.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#EvolutionaryModelingTools.@reaction_eq-Tuple{Symbol, Any, Expr, Vararg{Any}}","page":"References","title":"EvolutionaryModelingTools.@reaction_eq","text":"@reaction_eq name param eq [opts...]\n\nGenerate a reaction with the given name, parameters and equation.\n\nExample\n\n@reaction growth r X[i] --> 2X[i]\n\nis equivalent to\n\n@reaction growth begin\n    r * X\n    begin\n        i = ind[1]\n        X[i] += 1\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#EvolutionaryModelingTools.@ufunc-Tuple{Any}","page":"References","title":"EvolutionaryModelingTools.@ufunc","text":"@ufunc ex\n\nDefine a \"update\" function with an \"adapter\" methods used to parse args from model. \"update\" functions take arguments from system state and update system state.\n\nExample\n\nFor function definition:\n\n@ufunc Base.@propagate_inbounds growth_u!(ind::CartesianIndex{1}, x) = x[ind] += 1\n\nThis macro creates two methods, an \"adapter\" method\n\ngrowth_u!(ind, args::NamedTuple) = growth_u(ind, args.x)\n\nand the origin method\n\nBase.@propagate_inbounds growth_u!(ind::CartesianIndex{1}, x) = x[ind] += 1\n\ninfo: Info\nFor function definition with other macros, put those macros after this macro.\n\nwarning: Warning\nThe argument name t is reserved for time, arguments name rng is reserved for random number generator, and the argument name ind is preserved for index of \"reaction\". Don't use those variable names for other usage\n\n\n\n\n\n","category":"macro"},{"location":"reference/#EvolutionaryModelingTools.Scalar.ScalarType","page":"References","title":"EvolutionaryModelingTools.Scalar.ScalarType","text":"ScalarType{T}\n\nScalarType is a type of number used to represent a scalar value in a model. Its value is accessible via getindex and can be updated via setindex!.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EvolutionaryModelingTools.Scalar.scalar","page":"References","title":"EvolutionaryModelingTools.Scalar.scalar","text":"scalar(x)\n\nConvert x to a ScalarType.\n\n\n\n\n\n","category":"function"},{"location":"#EvolutionaryModelingTools","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"","category":"section"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"(Image: Build Status) (Image: codecov) (Image: GitHub) (Image: Docs stable) (Image: Docs dev)","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"A simple package provides an easy way to build evolutionary biology models and simulate them by Gillespie's direct method algorithm.","category":"page"},{"location":"#Why?","page":"EvolutionaryModelingTools","title":"Why?","text":"","category":"section"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"DifferentialEquations.jl is a brilliant suite solving deferential equations, including simulating jump process with Gillespie algorithm, and it is a very good choice. However, it is not suitable for solving differential equations with \"variable length\" state, which is the main reason why I created this package.","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"For example, in a SIR model, the host population is composed of \"Susceptible\", \"Infected\" and \"Recovered\".","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"In a normal case, there are only one type of \"host\" and one type \"virus\" in the system. Thus the state of host population can be represent as a vector u = [S, I, R], In a complex case, the host population can be composed of many types of \"host\" and infected by many types of \"virus\". In a system with n types of \"hosts\" and m types of \"viruses\", the state of host population can also be represented as a vector by concatenating the state of each component of host u = vcat(S, vec(I), vec(R)), where S is a vector of length n and I, R are matrixes of size n × m. However, in evolutionary biology, the \"mutation\" and \"extinction\" will change the types of hosts and viruses, which means the n and m changes during the evolution, and the length of the state vector u will also change.","category":"page"},{"location":"#How-to-use?","page":"EvolutionaryModelingTools","title":"How to use?","text":"","category":"section"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"The package Catalyst.jl provides a simple way to build biochemical reaction for DifferentialEquations.jl. Similarly, this package provides a macro @reaction_eq which generate reaction(s), with given equation.","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"For example, the infect reaction of above SIR model with multi-type of viruses can be defined as:","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"@reaction_eq infect β S + I[i] --> 2I[i]","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"where i donates the virus type.  The equation S + I[i] --> 2I[i] means the an host infected by the virus i infect a susceptible host with rate β, then convert the the susceptible host to a infectious host. This expression will not only generate one reaction but a group of reactions trough the index i.","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"However, the mutation and extinction can not be defined easily by the macro @reaction_eq currently. Thus the alternative macro @reaction provides a low-level way to build reaction(s)","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"@reaction mutation begin\n    @quickloop μ * I[i]\n    begin\n        i = ind[1]\n        I[i] -= 1 # the host individual is converted to another type\n        push!(I, 1) # add a new type of infectious host to the system\n        push!(α, randn() + α[i]) # the virulence of the new host type is generated randomly with mean `α[i]`\n    end\nend","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"This expression defined mutation of virus which contains two parts:","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"The @quickloop μ * I[i] defines how to calculate the rate of mutation,\nThe begin ... end block defines what happens when the host is mutated, where ind is a preserved variable which is used to store the index of the mutated host.","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"Once you have defined all reactions, put them together as a tuple:","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"reactions = (infect, mutation, ...)","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"and define the initial state and parameters of the system as a named tuple:","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"params = (β = 0.1, μ = 0.001, ..., S = scalar(100), I = [1], R = [0], α = [0.5])","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"where the scalar will create a type similar to Number, but it can be update in-place like Ref like S[] += 1.","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"Once reaction and parameters is defined, you can use gillespie to simulate the system:","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"max_time = 100 # the maximum time of simulation\nparams′, t, term = gillespie(max_time, params, reactions)","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"where the gillespie function returns an tuple t, ps′, term where t is the time when the simulation ends, params′ is an updated params, and term is a flag indicating whether the simulation is finished after the maximum time or break with given flag.","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"Note: Changes of the state will not be recorded by default, but you can use my another package RecordedArrays to record them, like this:","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"using RecordedArrays\nc = DiscreteClock(max_time) # clock store information of max_time\nS = recorded(DynamicEntry, c, 100) # create a recorded number as S with the clock c\nI = recorded(DynamicEntry, c, [1]) # create a recorded vector as I with the clock c\nR = recorded(DynamicEntry, c, [0]) # create a recorded vector as R with the clock c\nα = recorded(StaticEntry, c, [0.5]) # create a recorded vector as α with the clock c\nparams = (; β = 0.1, μ = 0.001, ..., S, I, R, α) # create new params with recorded S, I, R, α\ngillespie(c, params, reactions) # run the simulation with the clock and new params","category":"page"},{"location":"","page":"EvolutionaryModelingTools","title":"EvolutionaryModelingTools","text":"More information about RecordedArrays, see its documentation.","category":"page"},{"location":"example/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"example/#Logistic-Growth-with-noise","page":"Examples","title":"Logistic Growth with noise","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"This is a simple example of a logistic growth model with noise, where reaction is generated by @cfunc and @ufunc.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The determine differential equation of this model is:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"dotx = rx left(1 - fracxK right)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using RecordedArrays\nusing EvolutionaryModelingTools\nusing Random\nusing Plots\n\n# parameters\nconst r = 0.5 # growth rate\nconst d = 0.1 # mortality rate\nconst K = 100 # carrying capacity\n\n# clock\nc = ContinuousClock(100.0) # define a clock, the population will growth for 100 time unit\n\n# state\nx = recorded(DynamicEntry, c, 10)  # define a scalar to record population size\n\n# reactions\n\n@cfunc growth_c(r, x) = r * x\n@ufunc growth_u!(ind, x) = x[ind] += 1\ngrowth = Reaction(growth_c, growth_u!)\n\n@cfunc death_c(d, x) = d * x\n@ufunc death_u!(ind, x) = x[ind] -= 1\ndeath = Reaction(death_c, death_u!)\n\n@cfunc comp_c(r, K, x) = r * x * x / K\n@ufunc comp_u!(ind::CartesianIndex{0}, x) = x[ind] -=1\ncomp = Reaction(comp_c, comp_u!)\n\n# build the model\nps = (; r, d, K, x) # define the parameters for the model\nrs = (growth, death, comp) # define the reactions for the model\n\n# simulate\nps_new, t, state = gillespie(MersenneTwister(1), c, ps, rs)\n\n# plot\ntimeseries(ps_new.x;\n    grid=false, frame=:box, legend=false,\n    title=\"Population Dynamics\", xlabel=\"Time\", ylabel=\"Population Size\",\n)","category":"page"},{"location":"example/#Evolutionary-competitive-dynamics","page":"Examples","title":"Evolutionary competitive dynamics","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"A simple example model to simulate the evolution of a competition, where the reactions is defined by @reaction.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Unlike the previous example, this model consists of various of species introduced by mutation. And their competition is defined by a competition coefficient matrix M, where the element M_ij is the competition force from species j to i, and the element M_ii is the competition force from species i to itself.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The determine differential equation of this model is:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"dotx_i = rx left(1 - fracsum_j x_j M_ijK right)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using RecordedArrays\nusing EvolutionaryModelingTools\nusing Random\nusing Plots\n\n\n# parameters\nconst r = 0.5 # growth rate\nconst d = 0.1 # mortality rate\nconst K = 100 # carrying capacity\nconst μ = .01 # mutation rate\n\n# clock\nc = ContinuousClock(200.0) # define a clock, the population will growth for 10 time unit\n\n# state\nx = recorded(DynamicEntry, c, [10]) # define a vector to record population size\nm = recorded(StaticEntry, c, ones(1, 1)) # define a matrix to record competition coefficient\n\n# reactions\n@reaction growth begin\n    r * (1 - μ) * x\n    x[ind] += 1\nend\n\n@reaction mutation begin\n    @. r * μ * x\n    begin\n        push!(x, 1) # add a new species\n        n = length(x)\n        resize!(m, (n, n)) # resize the competition matrix\n        # new species compete with all other species and itself\n        m[:, n] = rand(rng, n)\n        m[n, 1:n-1] = rand(rng, n-1)\n    end\nend\n\n@reaction competition begin\n    begin\n        cc = r / K # baseline competition coefficient\n        @. cc * x * m * x'\n    end\n    begin\n        i = ind[1]\n        x[i] -= 1\n        if x[i] == 0 # check extinction\n            deleteat!(x, i)\n            resize!(m, (not(i), not(i)))\n        end\n    end\nend\n\n# hook function to check if all species is extinct\n@ufunc check_extinction(x) = isempty(x) ? :extinct : :finnish\n\n# build the model\nps = (; r, d, K, μ, x, m) # define the parameters for the model\nrs = (growth, mutation, competition) # define the reactions for the model\n\n# simulate\nps_new, t, state = gillespie(check_extinction, MersenneTwister(1), c, ps, rs)\n\n# plot\ntimeseries(ps_new.x;\n    grid=false, frame=:box, legend=false,\n    title=\"Population Dynamics\", xlabel=\"Time\", ylabel=\"Population Size\",\n)","category":"page"},{"location":"example/#SIR-model-with-vital-dynamics-and-logistic-population","page":"Examples","title":"SIR model with vital dynamics and logistic population","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"A simple SIR model with vital dynamics and logistic population, where the host population follows the logistic growth model.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"This model may contains more reactions than the previous example, which can be generated easily by @reaction_eq.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The deterministic differential equation of this model is:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"beginaligned\ndotS = r (S + I + R) - S(d + c (S + I + R) + beta I) \ndotI = I (beta S - d - c (S + I + R) - nu) \ndotR = R (nu - d - c (S + I + R))\nendaligned","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using RecordedArrays\nusing EvolutionaryModelingTools\nusing Random\nusing Plots\n\nconst T = 100.0\nconst β = 0.005\nconst ν = 0.01\nconst α = 0.2\nconst r = 0.5\nconst d = 0.1\nconst c = 0.001\nconst S = 100\nconst I = 10\nconst R = 0\n\n# epidemic dynamics\n@reaction_eq infection β S + I --> I + I\n@reaction_eq recovery ν I --> R\n@reaction_eq virulence α I --> 0 # death of infection host caused by virus\n# demography dynamics, generate reactions with @eval\nfor sym in (:S, :I, :R)\n    r_name = Symbol(:growth_, sym)\n    d_name = Symbol(:death_, sym)\n    @eval @reaction_eq $r_name r $sym --> S + $sym # growth\n    @eval @reaction_eq $d_name d $sym --> 0 # death\n    for sym′ in (:S, :I, :R)\n        c_name = Symbol(:competition_, sym, sym′)\n        @eval @reaction_eq $c_name c $sym + $sym′ --> $sym′ # competition\n    end\nend\n\nconst REACTIONS = (\n    infection, recovery, virulence,\n    growth_S, growth_I, growth_R,\n    death_S, death_I, death_R,\n    competition_SS, competition_SI, competition_SR,\n    competition_IS, competition_II, competition_IR,\n    competition_RS, competition_RI, competition_RR\n)\n\nclock = ContinuousClock(T)\nps = (;β, ν, α, r, d, c,\n    S=recorded(DynamicEntry, clock, S),\n    I=recorded(DynamicEntry, clock, I),\n    R=recorded(DynamicEntry, clock, R),\n)\nps_new, t, term = gillespie(MersenneTwister(1), clock, ps, REACTIONS)\n\nplt = plot(grid=false, frame=:box,\n    title=\"Population Dynamics\", xlabel=\"Time\", ylabel=\"Population Size\"\n)\ntimeseries!(plt, ps_new.S; label=\"S\")\ntimeseries!(plt, ps_new.I; label=\"I\")\ntimeseries!(plt, ps_new.R; label=\"R\")\nplt","category":"page"}]
}
